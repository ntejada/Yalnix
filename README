Shuo Zheng, Nic Tejada, Garrett Watumull

CHECKPOINT 5:

We believe we have essentially implemented TtyRead and TtyWrite. We are having some weird behavior, though, and want to ask you if this is just a product of the hardware. 

When we try to check the validity of the buffer after the user executes at the command TtyWrite(0, "Hello World\n"), the buffer passed into the user_context corresponds to page 131, which is outside the acceptable limit of our page table. We were wondering if this is due to some hardware special space or it's a bug in our code somehow. 

Also, we are wondering what implementation we should choose when reading from a new line. Say we enter 0123456789\n into the terminal, TtyReceive copies the string as well as the new line character and copies it into memory. Then say the user wants to read 10 chars, the next reader will read in an extra new line character. Should we code against this or keep this implementation? We are currently coding against this but we can change the implementation. 

Lastly, we have a strange character that pops up when we try to print out the buffer that the user passes to TtyRead. We can't predict when it will come but were wondering if you might have some pointers for where it might be coming from.

New Programs:

tty.* - contains InitTTY, DoTtyRead, DoTtyWrite, ReadFromBuffer. We created a struct TTY for each terminal containing read and write blocked queues for that terminal, a queue for overflow structs after a read operation that leaves characters, and other buffer pointers for execution. 

proc.* - this contains the TtyRecieveHandler and TtyTransmitHandler.

We are still working on CoW, but realized this would become more complicated after implementing TtyRead and TtyWrite, so we have yet to refactor it for the new operations specified. 



*****************************************************************

CHECKPOINT 4:

We successfully completed this checkpoint as well, getting Exit, Fork, Exec all to Work. We had a little difficulty forking at first but this turned out to be from not flushing the correct part of the PCB.

***New User Programs***
forkExecTest - tests out exec with a forked child (it execs exit56)  and has the parent delay and then wait on the child which tests also the handling of Zombie processes.
forkTest - tests out multiple forking 

We are looking to implement CoW as well but have not been able to fully flesh it out for this checkpoint.

******************************************************************

CHECKPOINT 3:

We successfully completed this checkpoint. We had to heavily modify our KernelStart function since we could not successfully call LoadProgram twice within the same process. Because we only have one running process besides our idle process, we could not rigorously test Delay and Brk, but both of these calls seemed to work when we tested them with init. 

frames.* - holds functions to keep track of available frames in physical memory. getNextFrame, initFrameList, and addFrame. 

switch.* - contains info for context switching. FirstSwitch places a valid kernel context into both the init and idle processes. MyKCS handles context switching between two processes where at least one already has a valid kernel context.

loadProg.* - program to create usercontext for a process

delay.* - contains functions to update a delayed blocked queue and place those processes back on the ready queue after there have been the specified number of clock ticks

init.* - modifications made to KernelStart and creation of functions copyStack and copyPages

initIdle.c / initInit.c - Idle and Init processes to run in KernelStart

trap.* - modifications made to Clock Handler: Context switches to a new process every clock tick and also updates the processes that called delay. 

proc.* - holds info the PCB struct and function to create PCB. DoBrk executes Brk call from a user process calling malloc. DoDelay places process that called delay onto delay_queue and context switches to a ready process. LoadNextProc removes any processes from the delay queue that are ready to execute and then pops of next process from ready queue to be executed, then performing a context switch. DoGetPid retrieves PID of current running process.

***User Programs***

initIdle - our idle process

initInit - tests our delay syscall

brkTest - tests our brk syscall and getPid 
